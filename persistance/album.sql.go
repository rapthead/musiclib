// Code generated by sqlc. DO NOT EDIT.
// source: album.sql

package persistance

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const getCommitedAlbumByID = `-- name: GetCommitedAlbumByID :one
SELECT created_at, old_path, title, date, release_date, barcode, source_id, comment, edition_title, mbid, rg_peak, rg_gain, updated_at, type, download_source, id, artist_id, state, path FROM album WHERE id = $1::uuid
`

func (q *Queries) GetCommitedAlbumByID(ctx context.Context, dollar_1 uuid.UUID) (Album, error) {
	row := q.db.QueryRowContext(ctx, getCommitedAlbumByID, dollar_1)
	var i Album
	err := row.Scan(
		&i.CreatedAt,
		&i.OldPath,
		&i.Title,
		&i.Date,
		&i.ReleaseDate,
		&i.Barcode,
		&i.SourceID,
		&i.Comment,
		&i.EditionTitle,
		&i.Mbid,
		&i.RgPeak,
		&i.RgGain,
		&i.UpdatedAt,
		&i.Type,
		&i.DownloadSource,
		&i.ID,
		&i.ArtistID,
		&i.State,
		&i.Path,
	)
	return i, err
}

const getCommitedAlbumPaths = `-- name: GetCommitedAlbumPaths :many
SELECT path FROM album
`

func (q *Queries) GetCommitedAlbumPaths(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getCommitedAlbumPaths)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var path string
		if err := rows.Scan(&path); err != nil {
			return nil, err
		}
		items = append(items, path)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDraftAlbumByID = `-- name: GetDraftAlbumByID :one
SELECT created_at, updated_at, path, title, date, release_date, barcode, source_id, comment, edition_title, mbid, rg_peak, rg_gain, type, download_source, id, artist_id, artist FROM draft_album WHERE id = $1::uuid
`

func (q *Queries) GetDraftAlbumByID(ctx context.Context, dollar_1 uuid.UUID) (DraftAlbum, error) {
	row := q.db.QueryRowContext(ctx, getDraftAlbumByID, dollar_1)
	var i DraftAlbum
	err := row.Scan(
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Path,
		&i.Title,
		&i.Date,
		&i.ReleaseDate,
		&i.Barcode,
		&i.SourceID,
		&i.Comment,
		&i.EditionTitle,
		&i.Mbid,
		&i.RgPeak,
		&i.RgGain,
		&i.Type,
		&i.DownloadSource,
		&i.ID,
		&i.ArtistID,
		&i.Artist,
	)
	return i, err
}

const getDraftAlbumPaths = `-- name: GetDraftAlbumPaths :many
SELECT path FROM draft_album
`

func (q *Queries) GetDraftAlbumPaths(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getDraftAlbumPaths)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var path string
		if err := rows.Scan(&path); err != nil {
			return nil, err
		}
		items = append(items, path)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertDraftAlbum = `-- name: InsertDraftAlbum :exec
INSERT INTO draft_album (
    id,
    artist,
    title,
    date,
    type,
    download_source,
    path,

    rg_gain,
    rg_peak,

    created_at,
    updated_at
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    NOW(),
    NOW()
)
`

type InsertDraftAlbumParams struct {
	ID             uuid.UUID          `json:"id"`
	Artist         sql.NullString     `json:"artist"`
	Title          sql.NullString     `json:"title"`
	Date           sql.NullTime       `json:"date"`
	Type           AlbumTypeEnum      `json:"type"`
	DownloadSource DownloadSourceEnum `json:"download_source"`
	Path           string             `json:"path"`
	RgGain         sql.NullFloat64    `json:"rg_gain"`
	RgPeak         sql.NullFloat64    `json:"rg_peak"`
}

func (q *Queries) InsertDraftAlbum(ctx context.Context, arg InsertDraftAlbumParams) error {
	_, err := q.db.ExecContext(ctx, insertDraftAlbum,
		arg.ID,
		arg.Artist,
		arg.Title,
		arg.Date,
		arg.Type,
		arg.DownloadSource,
		arg.Path,
		arg.RgGain,
		arg.RgPeak,
	)
	return err
}

const listAlbums = `-- name: ListAlbums :many
SELECT
    artist.name AS artist_name,
    album.date AS album_date,
    album.title AS album_title,
    album.state AS album_state
FROM album
JOIN artist ON album.artist_id = artist.id
ORDER BY artist.name ASC, album.date ASC, album.title ASC
`

type ListAlbumsRow struct {
	ArtistName string         `json:"artist_name"`
	AlbumDate  time.Time      `json:"album_date"`
	AlbumTitle string         `json:"album_title"`
	AlbumState AlbumStateEnum `json:"album_state"`
}

func (q *Queries) ListAlbums(ctx context.Context) ([]ListAlbumsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAlbums)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAlbumsRow
	for rows.Next() {
		var i ListAlbumsRow
		if err := rows.Scan(
			&i.ArtistName,
			&i.AlbumDate,
			&i.AlbumTitle,
			&i.AlbumState,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDraftAlbums = `-- name: ListDraftAlbums :many
SELECT
    draft_album.id AS album_id,
    draft_album.path AS album_path,
    draft_album.date AS album_date,
    draft_album.title AS album_title
FROM draft_album
ORDER BY album_path ASC, draft_album.date ASC, draft_album.title ASC
`

type ListDraftAlbumsRow struct {
	AlbumID    uuid.UUID      `json:"album_id"`
	AlbumPath  string         `json:"album_path"`
	AlbumDate  sql.NullTime   `json:"album_date"`
	AlbumTitle sql.NullString `json:"album_title"`
}

func (q *Queries) ListDraftAlbums(ctx context.Context) ([]ListDraftAlbumsRow, error) {
	rows, err := q.db.QueryContext(ctx, listDraftAlbums)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDraftAlbumsRow
	for rows.Next() {
		var i ListDraftAlbumsRow
		if err := rows.Scan(
			&i.AlbumID,
			&i.AlbumPath,
			&i.AlbumDate,
			&i.AlbumTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAlbum = `-- name: UpdateAlbum :exec
UPDATE album SET
    artist_id		= $2,
    title			= $3,
    date			= $4,
    mbid			= $5,
    type			= $6,
    edition_title	= $7,
    release_date	= $8,
    barcode			= $9,
    download_source	= $10,
    source_id		= $11,
    comment			= $12,
    state		    = $13,

    updated_at = NOW()
WHERE id = $1
`

type UpdateAlbumParams struct {
	ID             uuid.UUID          `json:"id"`
	ArtistID       uuid.UUID          `json:"artist_id"`
	Title          string             `json:"title"`
	Date           time.Time          `json:"date"`
	Mbid           sql.NullString     `json:"mbid"`
	Type           AlbumTypeEnum      `json:"type"`
	EditionTitle   sql.NullString     `json:"edition_title"`
	ReleaseDate    sql.NullTime       `json:"release_date"`
	Barcode        sql.NullString     `json:"barcode"`
	DownloadSource DownloadSourceEnum `json:"download_source"`
	SourceID       sql.NullString     `json:"source_id"`
	Comment        sql.NullString     `json:"comment"`
	State          AlbumStateEnum     `json:"state"`
}

func (q *Queries) UpdateAlbum(ctx context.Context, arg UpdateAlbumParams) error {
	_, err := q.db.ExecContext(ctx, updateAlbum,
		arg.ID,
		arg.ArtistID,
		arg.Title,
		arg.Date,
		arg.Mbid,
		arg.Type,
		arg.EditionTitle,
		arg.ReleaseDate,
		arg.Barcode,
		arg.DownloadSource,
		arg.SourceID,
		arg.Comment,
		arg.State,
	)
	return err
}
